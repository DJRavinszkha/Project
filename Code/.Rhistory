fit_eb = eBayes(fit_reox)
stat_overview_treox = topTable(fit_eb, coef = 5) # Get info about top 10 DEG's (t24 vs treox)
fit_eb$p.value[1:4,]
# Generate volcano plot
pdf(file = "Output/Volcano plot t24 vs treox.pdf")
volcanoplot(fit_eb, coef = 5) # Create volcano plot comparing t24 with treox
title("t24 vs treox")
dev.off()
volcanoplot(fit_eb, coef = 5)
# Factorise the grouping variables
timepoints_hypo <- factor(c(rep(c("t0", "t8", "t24"), each=3)))
samples_hypo = factor(c("I", "II", "III", "I", "II", "III", "I", "III", "IIII"))
design<- model.matrix(~ 0 + samples_hypo + timepoints_hypo)
colnames(design)<- c("I", "II", "III", "IIII", "t24", "t8")
# Fit a linear model
fit_hypo<- lmFit(data_norm[,1:9], design)
fit_eb = eBayes(fit_hypo)
stat_overview_t8 = topTable(fit_eb, coef = 6) # Get info about top 10 DEG's (t0 vs t8)
stat_overview_t24 = topTable(fit_eb, coef = 5) # Get info about top 10 DEG's (t vs t24)
fit_eb$p.value[1:4,]
volcanoplot(fit_eb, coef = 6) # Create volcano plot comparing t0 with t8
title("t0 vs t8")
volcanoplot(fit_eb, coef = 5) # Create volcano plot comparing t0 with t24
title("t0 vs t24")
pdf(file = "Output/Volcano plot t0 vs t8.pdf")
volcanoplot(fit_eb, coef = 6) # Create volcano plot comparing t0 with t8
title("t0 vs t8")
dev.off()
pdf(file = "Output/Volcano plot t0 vs t24.pdf")
volcanoplot(fit_eb, coef = 5) # Create volcano plot comparing t0 with t24
title("t0 vs t24")
dev.off()
# Factorise the grouping variables
timepoints_reox <- factor(c(rep(c("t24", "treox"), each=3)))
samples_reox = factor(c("I", "III", "IIII", "I", "II", "III"))
design<- model.matrix(~ 0 + samples_reox + timepoints_reox)
colnames(design)<- c("I", "II", "III", "IIII", "treox")
# Fit a linear model
fit_reox<- lmFit(data_norm[,7:12], design)
fit_eb = eBayes(fit_reox)
stat_overview_treox = topTable(fit_eb, coef = 5) # Get info about top 10 DEG's (t24 vs treox)
fit_eb$p.value[1:4,]
# Generate volcano plot
pdf(file = "Output/Volcano plot t24 vs treox.pdf")
volcanoplot(fit_eb, coef = 5) # Create volcano plot comparing t24 with treox
title("t24 vs treox")
dev.off()
volcanoplot(fit_eb, coef = 5)
title("t24 vs treox")
# Let's load a reference dataset
Y_genes = read.delim("Data/Y_chromosome_EnsemblGeneIDs.txt")
Y_genes = merge(Y_genes, data_final, by = 1)
# Add gene symbols and description to dataset
ensembl = useMart("ensembl", "hsapiens_gene_ensembl")
gene_ids = rownames(data_norm);
annotation = getBM(attributes = c("ensembl_gene_id", 'hgnc_symbol'),
filter = "ensembl_gene_id",
values =  gene_ids,
mart = ensembl)
data_final = merge(data_norm, annotation, by.x = 0, by.y = 1, all = TRUE)
colnames(data_final)[1] = "ENSEMBL ID"
colnames(data_final)[14] = "Gene Symbol"
# The code below adds description but introduces addtional rows due to multiple descriprions
# Therefore, it is commented out.
# description = getBM(attributes = c("ensembl_gene_id", 'interpro_description'),
#                    filter = "ensembl_gene_id",
#                    values =  gene_ids,
#                    mart = ensembl,
#                    uniqueRows = TRUE)
# description = description[uunion(description[,1]), ]
#
#
# data_final = merge(data_final, description, by = 1, all = TRUE)
# colnames(data_final)[1] = "ENSEMBL ID"
# colnames(data_final)[14:15] = c("Gene Symbol", "Gene Description")
View(data_final)
# Let's load a reference dataset
Y_genes = read.delim("Data/Y_chromosome_EnsemblGeneIDs.txt")
Y_genes = merge(Y_genes, data_final, by = 1)
# Calculate mean background expression
background_expr = mean(as.numeric(unlist(Y_genes[,2:13]), na.rm = TRUE))
# Determine which genes are above background
aboveBG = data_final[which(rowMeans(data_final[,2:13])>background_expr),]
aboveBG = data.frame(aboveBG[,1], TRUE)
belowBG = data_final[which(rowMeans(data_final[,2:13])<=background_expr),]
belowBG = data.frame(belowBG[,1], FALSE)
colnames(aboveBG) = c("ENSEMBL ID", "aboveBackground")
colnames(belowBG) = c("ENSEMBL ID", "aboveBackground")
# implement results in dataset
data_final = merge(data_final, aboveBG, by = 1, all = TRUE)
data_final[is.na(data_final$aboveBackground),15] = FALSE
write.table(data_final, "Output/Hypoxia Final Dataset.txt", sep = ",",
row.names = FALSE)
write.table(x, file, append = FALSE, sep = " ", dec = ".",
row.names = TRUE, col.names = TRUE)
write.table(data_final, "Output/Hypoxia Final Dataset.txt", sep = ",",
row.names = FALSE)
View(data_final)
description = getBM(attributes = c("ensembl_gene_id", 'interpro_description'),
filter = "ensembl_gene_id",
values =  gene_ids,
mart = ensembl,
uniqueRows = TRUE)
description = description[uunion(description[,1]), ]
View(description)
description = description[!duplicated(description$ensembl_gene_id),]
View(description)
data_final = merge(data_final, description, by = 1, all = TRUE)
colnames(data_final)[1] = "ENSEMBL ID"
colnames(data_final)[14:15] = c("Gene Symbol", "Gene Description")
View(data_final)
# Let's load a reference dataset
Y_genes = read.delim("Data/Y_chromosome_EnsemblGeneIDs.txt")
Y_genes = merge(Y_genes, data_final, by = 1)
# Calculate mean background expression
background_expr = mean(as.numeric(unlist(Y_genes[,2:13]), na.rm = TRUE))
# Determine which genes are above background
aboveBG = data_final[which(rowMeans(data_final[,2:13])>background_expr),]
aboveBG = data.frame(aboveBG[,1], TRUE)
belowBG = data_final[which(rowMeans(data_final[,2:13])<=background_expr),]
belowBG = data.frame(belowBG[,1], FALSE)
colnames(aboveBG) = c("ENSEMBL ID", "aboveBackground")
colnames(belowBG) = c("ENSEMBL ID", "aboveBackground")
# implement results in dataset
data_final = merge(data_final, aboveBG, by = 1, all = TRUE)
data_final[is.na(data_final$aboveBackground),15] = FALSE
# Let's load a reference dataset
Y_genes = read.delim("Data/Y_chromosome_EnsemblGeneIDs.txt")
Y_genes = merge(Y_genes, data_final, by = 1)
# Calculate mean background expression
background_expr = mean(as.numeric(unlist(Y_genes[,2:13]), na.rm = TRUE))
# Determine which genes are above background
aboveBG = data_final[which(rowMeans(data_final[,2:13])>background_expr),]
aboveBG = data.frame(aboveBG[,1], TRUE)
belowBG = data_final[which(rowMeans(data_final[,2:13])<=background_expr),]
belowBG = data.frame(belowBG[,1], FALSE)
colnames(aboveBG) = c("ENSEMBL ID", "aboveBackground")
colnames(belowBG) = c("ENSEMBL ID", "aboveBackground")
# implement results in dataset
data_final = merge(data_final, aboveBG, by = 1, all = TRUE)
data_final[is.na(data_final$aboveBackground),15] = FALSE
write.table(data_final, "Output/Hypoxia Final Dataset.txt", sep = ",",
row.names = FALSE)
if (!requireNamespace("BiocManager", quietly = TRUE))
install.packages("BiocManager")
BiocManager::install("anamiR")
BiocManager::install("anamiR")
R.version.
R.version.string
miRNA_names
#==== miRNA version conversion ===#
miRNA_names <- row.names(mirna)                                       # Store miRNA names
#library(anamiR)
library(limma)
library(rstudioapi)
# Get data in correct format
current_path <- getActiveDocumentContext()$path
setwd(dirname(current_path ))
mrna = read.delim('../Data/GeneExpressionNormalized.txt', check.names = FALSE) #Load expression data
mirna = read.delim('../Data/miRNAexpression.txt', check.names = FALSE) #Load miRNA expression data
key <- mrna[,1:2] # Key for maintaining gene symbol and entrez gene ID
# Column names are different for miRNA and mRNA datasets, but are conserved with sample names in SampleGroups.xlsx
#IE FGS_01 is the name of sample 1;
#where miRNA sample is US10063773_254606410403_S01_miRNA_107_Sep09_1_1 - 2;
#and mRNA sample is FGS_01_410978_1_1
#=== Here we change the columns names of mrna (mRNA samples) to the sample names ===
mrna = subset(mrna, select = -2) # Remove gene symbol column
columns = colnames(mrna)
columns[2:29] <- substr(unlist(columns[2:29]), 1, 6) #Only keep first 6 characters of column names
colnames(mrna) <- columns # Assign this to the actual column names
#=== Here we change the columns names of mirna (miRNA samples) to the sample names ===
labels = read.delim("../Data/colNames.csv", sep = ',', header = FALSE, colClasses = 'character')
columns = colnames(mirna)
columns[[1]] <- 'miRNA'
for (i in rep(2:length(colnames(mirna)))){
for ( j in rep(1:nrow(labels))){
if(colnames(mirna[i]) == labels[j,1]){
columns[[i]] = labels[j,3] # Assign correct column name to array
# print(labels[j,1])
# print(colnames(mirna[i]))
# print(labels[j, 3])
# print("======")
}
}
}
colnames(mirna) <- columns
# Set rownames for mrna
rownames(mrna) <- mrna[,1]
mrna <- mrna[,2:29]
# Set rownames for mirna
rownames(mirna) <- mirna[,1]
mirna <- mirna[,2:29]
#=== Here we initialise the sample grouping ===
sampleGroups <- read.delim("../Data/SampleGroups.csv", sep = ',', header = TRUE, colClasses = 'character')
sampleGroups <- sampleGroups[,6:7]
index_cholestatic <- sampleGroups == 'cholestatic'
sampleGroups$id[index_cholestatic[,1]] <- 1
index_drained <- sampleGroups == 'drained'
sampleGroups$id[index_drained[,1]] <- 2
index_control <- sampleGroups == 'control'
sampleGroups$id[index_control[,1]] <- 3
#=============================#
# Different gene expression  #
#=============================#
# First we identify differentially expressed genes for the mRNA's
design_matrix <- model.matrix(~ 0 + factor(c(1,1,1,1,1,1,1,1,1,
2,2,2,2,2,2,2,2,2,2,
3,3,3,3,3,3,3,3,3)))
colnames(design_matrix) <- c("cholestasis", "drained", "control")
cont_matrix <- makeContrasts (drained_v_control = drained - control,
cholestasis_v_control = cholestasis - control,
cholestasis_v_drained = cholestasis - drained,
levels = design_matrix)
fit <- lmFit(mrna, design_matrix)
fit_contrast <- contrasts.fit(fit, cont_matrix)
fit_contrast <- eBayes(fit_contrast)
results <- decideTests(fit_contrast)
summary(results)
top_genes <- topTable (fit_contrast, number = nrow(mrna), adjust = "BH")
# Subsequently we do the same for the miRNA data
design_matrix <- model.matrix(~ 0 + factor(c(1,1,1,1,1,1,1,1,1,
2,2,2,2,2,2,2,2,2,2,
3,3,3,3,3,3,3,3,3)))
colnames(design_matrix) <- c("cholestasis", "drained", "control")
cont_matrix <- makeContrasts (drained_v_control = drained - control,
cholestasis_v_control = cholestasis - control,
cholestasis_v_drained = cholestasis - drained,
levels = design_matrix)
#Here we change NA's with rownmeans SHOULD BE CHANGED LATER!!!
omitmirna <- mirna
omitmirna[is.na(omitmirna)] <- mean(as.matrix(mirna), na.rm = TRUE)
fit2 <- lmFit(omitmirna, design_matrix)
fit_contrast2 <- contrasts.fit(fit2, cont_matrix)
fit_contrast2 <- eBayes(fit_contrast2)
results2 <- decideTests(fit_contrast2)
summary(results2)
top_genes2 <- topTable (fit_contrast2, number = nrow(mirna), adjust = "BH")
#=============================#
# Create phenotype data       #
#=============================#
pheno.mrna = labels
pheno.mrna[[1]] <- colnames(mrna)
colnames(pheno.mrna) <- c("", "Subtype", "ER")
# Set controls
case <- pheno.mrna[,'Subtype'] == "cholestatic"
pheno.mrna[case,3] <- 'case'
# Set drained
case <- pheno.mrna[,'Subtype'] == "drained"
pheno.mrna[case,3] <- 'case'
# set controls
case <- pheno.mrna[,'Subtype'] == "control"
pheno.mrna[case,3] <- 'control'
# Order cases and controls
pheno.mrna <- pheno.mrna[order(as.character(pheno.mrna$ER)),]
# Set pheno.mirna which is identical to pheno.mrna
pheno.mirna = pheno.mrna
#=============================#
# Summarised experiment class #
#=============================#
# First we change the dataframes into matrices as the miRrna package works with matrices.
pheno.mrna <- as.matrix(pheno.mrna)
pheno.mirna <- as.matrix(pheno.mirna)
mrna = data.matrix(mrna)
mirna = data.matrix(mirna)
# Fill NA's with mean for the time-being
mrna[is.na(mrna)] <- mean(mrna, na.rm = TRUE)
mirna[is.na(mirna)] <- mean(mirna, na.rm = TRUE)
# Remove drained cases from mrna
index = rep(TRUE, length(colnames(mrna)))
for(i in 1:length(colnames(mrna))){
# if current column name is present in a list of all column names of cases:
if(colnames(mrna)[i] %in% pheno.mrna[pheno.mrna[,2]=="drained",1]){
index[i] <- FALSE
}
}
mrna <- mrna[,index]
# Remove drained cases from mirna
index = rep(TRUE, length(colnames(mirna)))
for(i in 1:length(colnames(mirna))){
# if current column name is present in a list of all column names of cases:
if(colnames(mirna)[i] %in% pheno.mirna[pheno.mirna[,2]=="drained",1]){
index[i] <- FALSE
}
}
mirna <- mirna[,index]
# Remove drained cases from the phenotype data
pheno.mrna <- pheno.mrna[!(pheno.mrna[,2]=="drained"),]
pheno.mirna <- pheno.mirna[!(pheno.mirna[,2]=="drained"),]
#=============================#
# Change DE gene table format #
#=============================#
# First we change the layout for the mRNA data
mrna_d <- top_genes[,c(2,6,7)]
mrna_d[["mean_case"]] <- 0
mrna_d[["mean_control"]] <- 0
# Seperate controls from cases
index = rep(FALSE, length(colnames(mrna)))
for(i in 1:length(colnames(mrna))){
# if current column name is present in a list of all column names of cases:
if(colnames(mrna)[i] %in% pheno.mrna[pheno.mrna[,3]=="case",1]){
index[i] <- TRUE
}
}
mrna.case <- mrna[,index]
mrna.control <- mrna[,!index]
# Calculate means
mean_control <- rowMeans(mrna.control)
mean_case <- rowMeans(mrna.case)
# Include means in mrna_d
mrna_d[[4]] <- mean_case
mrna_d[[5]] <- mean_control
colnames(mrna_d) <- c("log-ratio", "P-Value", "P-adjust", "mean_case", "mean_control")
#=============================================#
# Now we change the format for the miRNA data #
#=============================================#
mirna_d <- top_genes2[,c(2,6,7)]
mirna_d[["mean_case"]] <- 0
mirna_d[["mean_control"]] <- 0
# Seperate controls from cases
index = rep(FALSE, length(colnames(omitmirna)))
for(i in 1:length(colnames(omitmirna))){
# if current column name is present in a list of all column names of cases:
if(colnames(omitmirna)[i] %in% pheno.mirna[pheno.mirna[,3]=="case",1]){
index[i] <- TRUE
}
}
mirna.case <- omitmirna[,index]
mirna.control <- omitmirna[,!index]
# Calculate means
mean_control <- rowMeans(mirna.control[,2:length(mirna.control)])
mean_case <- rowMeans(mirna.case[,2:length(mirna.case)])
# Include means in omitmirna
mirna_d[[4]] <- mean_case
mirna_d[[5]] <- mean_control
colnames(mirna_d) <- c("log-ratio", "P-Value", "P-adjust", "mean_case", "mean_control")
# # Set first column of phenotype data as rowname
# rownames(pheno.mrna) <- pheno.mrna[,1]
# pheno.mrna <- pheno.mrna[,2:3]
# pheno.mirna <- pheno.mrna # pheno.mirna is identical to pheno.mrna (for clarity they both exist)
#
#=============================================#
# Now we change the miRNA name version        #
#=============================================#
#==== miRNA version conversion ===#
miRNA_names <- row.names(mirna)                                       # Store miRNA names
miRNA_names
version = checkMiRNAVersion(row.names(mirna), verbose = TRUE)         # Check miRNA name version
miRNA_names <- miRNA_NameToAccession(miRNA_names, version = version)  # Include Accession numbers
library(miRBaseConverter)
library(jsonlite)
miRNA_names <- miRNA_NameToAccession(miRNA_names, version = version)  # Include Accession numbers
#==== miRNA version conversion ===#
miRNA_names <- row.names(mirna)                                       # Store miRNA names
version = checkMiRNAVersion(row.names(mirna), verbose = TRUE)         # Check miRNA name version
miRNA_names <- miRNA_NameToAccession(miRNA_names, version = version)  # Include Accession numbers
miRNA_names
head(miRNA_names)
prefix <- "https://app1.bioinformatics.mdanderson.org/tarhub/_design/basic/_view/"
link_temaplate <- paste(prefix, 'by_matureMIRcount?startkey=[%s,%s]&endkey=[%s,{}]',  sep = "")
minSources = 1 # Set minimum number of sources
mirna_targets <- list() # Initialise the mina_targets matrix
list = rep( list(list(rep(0, 3))), nrow(mirna) )
target = list()
progress <- txtProgressBar(min = 0, max = nrow(miRNA_names), initial = 0)# Initiate progress bar
options(timeout = 100000) # Set timeout to increase time for retrying queries
error_list = list()
error_count = 0
step = 0
nTargets = 0
i=1
name = paste("%22", miRNA_names[2,1], "%22", sep = "")        # Set name in correct URL format
name
miRNA_link <- sprintf(link_temaplate, name, minSources, name) # Create URL link to miRNA targets
miRNA_link
miRNA_names[2,1]
miRNA_names[1,1]
#==== miRNA version conversion ===#
miRNA_names <- row.names(mirna)                                       # Store miRNA names
version = checkMiRNAVersion(row.names(mirna), verbose = TRUE)         # Check miRNA name version
miRNA_names <- miRNA_NameToAccession(miRNA_names, version = version)  # Include Accession numbers
miRNA_names_v18 <- miRNA_AccessionToName(miRNA_names[,2],
targetVersion = "v18")       # Convert to version 18
#=== miRNA targer prediction - query ===#
prefix <- "https://app1.bioinformatics.mdanderson.org/tarhub/_design/basic/_view/"
link_temaplate <- paste(prefix, 'by_matureMIRcount?startkey=[%s,%s]&endkey=[%s,{}]',  sep = "")
minSources = 1 # Set minimum number of sources
mirna_targets <- list() # Initialise the mina_targets matrix
list = rep( list(list(rep(0, 3))), nrow(mirna) )
target = list()
progress <- txtProgressBar(min = 0, max = nrow(miRNA_names), initial = 0)# Initiate progress bar
options(timeout = 100000) # Set timeout to increase time for retrying queries
error_list = list()
error_count = 0
step = 0
nTargets = 0
for (i in 1:nrow(miRNA_names)){
name = paste("%22", miRNA_names[i,1], "%22", sep = "")        # Set name in correct URL format
miRNA_link <- sprintf(link_temaplate, name, minSources, name) # Create URL link to miRNA targets
target <- try(fromJSON(miRNA_link))                           # Query the miRNA - try returns error for server errors
if (typeof(target) == 'char'){
error_list <- append(error_list, c(name, target))           # Capture error
error_count <- error_count + 1                              # Keep track of number of errors
next                                                        # Jump to next iteration
}
#names(target)[3] <- miRNA_names[i]                                 # Set list item name to miRNA name
mirna_targets <- append(mirna_targets, list(target$rows))           # Add the miRNA targets to one long list of targets
nTargets <- nTargets +  nrow(as.matrix(target$rows))                # Keep track of the total number of targets
# substr(unlist(columns[2:29]), 1, 6)
step = step + 1
setTxtProgressBar(progress, step)# Update progress bar
}
print(sprintf("miRNA_target_query executed succesfully with %s errors", error_count))
#=== The section below converts the mirna_targets list into one long data frame ===#
progress <- txtProgressBar(min = 0, max = step, initial = 0) # Initiate progress bar
mirna_targets_df <- data.frame(matrix(nrow = nTargets, ncol = 3))         # Initialise mirna_targets_df
colnames(mirna_targets_df) <- c("miRNA", "mRNA", "sources")               # set the column names
index = 1                                                                 # Initialise index
for (i in 1:step){
targets <- data.frame(mirna_targets[[i]])           # load targets from mirna_targets
index_end <- index + nrow(targets) - 1              # Set end of index range
mirna_targets_df[index:index_end,1:2] <-
t(data.frame(strsplit(targets[,1], ":")))         # Set miRNA and mRNA names
mirna_targets_df[index:index_end,3] <-
as.numeric(unlist(targets[,2])[c(FALSE, TRUE)])   # Set number of sources
index <- index_end + 1
setTxtProgressBar(progress, step)                   # Update progress bar
}
View(mirna_targets)
head(mirna_targets)
View(mirna_targets)
step
nTargets
View(mirna_targets_df)
#=== The section below converts the mirna_targets list into one long data frame ===#
progress <- txtProgressBar(min = 0, max = step, initial = 0) # Initiate progress bar
mirna_targets_df <- data.frame(matrix(nrow = nTargets, ncol = 3))         # Initialise mirna_targets_df
colnames(mirna_targets_df) <- c("miRNA", "mRNA", "sources")               # set the column names
index = 1                                                                 # Initialise index
targets <- data.frame(mirna_targets[[i]])           # load targets from mirna_targets
index_end <- index + nrow(targets) - 1              # Set end of index range
mirna_targets_df[index:index_end,1:2] <-
t(data.frame(strsplit(targets[,1], ":")))         # Set miRNA and mRNA names
mirna_targets_df[index:index_end,3] <-
as.numeric(unlist(targets[,2])[c(FALSE, TRUE)])   # Set number of sources
index <- index_end + 1
setTxtProgressBar(progress, step)                   # Update progress bar
#=== The section below converts the mirna_targets list into one long data frame ===#
progress <- txtProgressBar(min = 0, max = step, initial = 0) # Initiate progress bar
#=== The section below converts the mirna_targets list into one long data frame ===#
progress <- txtProgressBar(min = 0, max = step, initial = 0) # Initiate progress bar
mirna_targets_df <- data.frame(matrix(nrow = nTargets, ncol = 3))         # Initialise mirna_targets_df
colnames(mirna_targets_df) <- c("miRNA", "mRNA", "sources")               # set the column names
index = 1                                                                 # Initialise index
targets <- data.frame(mirna_targets[[i]])           # load targets from mirna_targets
index_end <- index + nrow(targets) - 1              # Set end of index range
mirna_targets_df[index:index_end,1:2] <-
t(data.frame(strsplit(targets[,1], ":")))         # Set miRNA and mRNA names
mirna_targets_df[index:index_end,1:2]
mirna_targets
mirna_targets[1:5,1:2]
mirna_targets[,1:2]
mirna_targets[,1]
mirna_targets[1]
mirna_targets_df[index:index_end,1:2]
View(mirna_targets_df)
targets
i
mirna_targets[[i]]
mirna_targets[[i]][1]
mirna_targets[[7]][1]
mirna_targets[[8]][1]
mirna_targets[[8]][1] == NULL
mirna_targets[[8]][[1]] == NULL
length(mirna_targets[8])
length(mirna_targets[7])
nrow(mirna_targets[8])
nrow(mirna_targets[7])
nrow(unlist(mirna_targets[7]))
unlist(mirna_targets[7])
targets <- data.frame(mirna_targets[[i]])           # load targets from mirna_targets
targets
length(targets)
targets <- data.frame(mirna_targets[[7]])           # load targets from mirna_targets
length(targets)
length(targets) == 0)
length(targets) == 0
targets
targets <- data.frame(mirna_targets[[8]])           # load targets from mirna_targets
length(targets) == 0
#=== The section below converts the mirna_targets list into one long data frame ===#
progress <- txtProgressBar(min = 0, max = step, initial = 0) # Initiate progress bar
mirna_targets_df <- data.frame(matrix(nrow = nTargets, ncol = 3))         # Initialise mirna_targets_df
colnames(mirna_targets_df) <- c("miRNA", "mRNA", "sources")               # set the column names
index = 1                                                                 # Initialise index
for (i in 1:step){
targets <- data.frame(mirna_targets[[i]])           # load targets from mirna_targets
if (length(targets) == 0){                          # If no targets, then skip to next iteration
next
}
index_end <- index + nrow(targets) - 1              # Set end of index range
mirna_targets_df[index:index_end,1:2] <-
t(data.frame(strsplit(targets[,1], ":")))         # Set miRNA and mRNA names
mirna_targets_df[index:index_end,3] <-
as.numeric(unlist(targets[,2])[c(FALSE, TRUE)])   # Set number of sources
index <- index_end + 1
setTxtProgressBar(progress, i)                   # Update progress bar
}
View(mirna_targets_df)
write.csv(mirna_targets_df,  "miRNA_targets.csv")
remove(target)
target <- try(fromJSON(miRNA_link))                           # Query the miRNA - try returns error for server errors
typeof(target)
